
#include <cmath>
#include <cstring>
#include <ctime>
#include <iostream>
#include <random>
#include "SquareMazeGenerator.h"


const char SquareMazeGenerator::COMMANDS[][11]{ ">addDots", ">addLines", ">printMaze", ">list", ">randMaze", ">exit"};
const char SquareMazeGenerator::NUMBER_OF_COMMANDS = 6;
const size_t SquareMazeGenerator::BUFF_SIZE = 256;

void SquareMazeGenerator::createMaze(const SquareMaze_TwoBits& maze) {
	srand((unsigned int)time(0));

	std::cout << std::endl;
	std::cout << "    ------------------------------------\n";
	std::cout << "    | Welcome to Square Maze Generator |\n";
	std::cout << "    ------------------------------------\n\n";
	std::cout << "Type '>list' to see all available commands.\n";

	do {
		// User input.
		std::cout << "Type a command:\n";
		char buff[BUFF_SIZE];
		std::cin.getline(buff, BUFF_SIZE, '\n');
		if (!std::cin.good()) {
			std::cin.clear();
			std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
		}
		
		size_t cmdIndex = 0;
		for (; cmdIndex < NUMBER_OF_COMMANDS; ++cmdIndex)
			if (!strcmp(buff, COMMANDS[cmdIndex]))    // Find a matching command.
				break;
		
		switch (cmdIndex)
		{
		case 0:
			addDots(maze);
			break;
		case 1:
			addLines(maze);
			break;
		case 2:
			maze.print();
			break;
		case 3:
			printCommands();
			break;
		case 4:
			randomMaze(maze);
			break;
		case 5:
			std::cout << "Exiting . . .\n";
			return;
		default:
			std::cout << "Invalid command! Type '>list' to see all available commands.\n";
		}

	} while (true);
}

void SquareMazeGenerator::addDots(const SquareMaze_TwoBits& maze) {
	// Console input.
	size_t dotCount = 0;
	do {
		std::cout << "How many dots: ";
		std::cin >> dotCount;
		if (std::cin.good()) {
			std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');    // Ignore everything after the number of dots.
			break;
		}
		else {
			std::cout << "Invalid number of dots, please try again.\n";
			std::cin.clear();
			std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
		}
	} while (true);

	addDots(maze, dotCount);    // Draw the dots.
	
	std::cout << dotCount << " dots added.\n";
}
void SquareMazeGenerator::addDots(const SquareMaze_TwoBits& maze, size_t dotCount) {
	for (size_t i = 0; i < dotCount; ++i) {
		// Pick a random point and set it to 1.
		maze.setPixel(rand() % maze.getSize(), rand() % maze.getSize(), 1);

		// RAND_MAX is usially 32767 so the above will not work for mazes with bigger side length than that.
	}
}
void SquareMazeGenerator::addLines(const SquareMaze_TwoBits& maze) {
	// Console input.
	std::cout << "Type '0' for horizontal lines, type anything else for vertical lines: ";
	char vertOrHor = 0;
	std::cin >> vertOrHor;
	std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
	if (vertOrHor == '0')
		vertOrHor = 0;    // horizontal

	size_t lineCount = 0, lineLen = 0;
	do {
		std::cout << "Enter line count and line length: ";
		std::cin >> lineCount >> lineLen;
		if (std::cin.good()) {
			std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');    // Ignore everything after line length.
			break;
		}
		else {
			std::cout << "Invalid parameters, please try again.\n";
			std::cin.clear();
			std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
		}
	} while (true);

	// Draw the lines.
	if (vertOrHor)
		addVerticalLines(maze, lineCount, lineLen);
	else
		addHorizontalLines(maze, lineCount, lineLen);

	std::cout << lineCount << " lines added with length " << lineLen << ".\n";
}
void SquareMazeGenerator::addVerticalLines(const SquareMaze_TwoBits& maze, size_t lineCount, size_t lineLen) {
	for (size_t i = 0; i < lineCount; ++i) {
		size_t row = rand() % maze.getSize(), col = rand() % maze.getSize();    // Choose random point in the maze.

		// Draw a line from top to bottom.
		size_t rowIndex = row;
		do {
			maze.setPixel(rowIndex, col, 1);
			++rowIndex;
		} while (rowIndex < maze.getSize() && rowIndex < row + lineLen);
	}
}
void SquareMazeGenerator::addHorizontalLines(const SquareMaze_TwoBits& maze, size_t lineCount, size_t lineLen) {
	for (size_t i = 0; i < lineCount; ++i) {
		size_t row = rand() % maze.getSize(), col = rand() % maze.getSize();    // Choose random point in the maze.

		// Draw a line from left to right.
		size_t colIndex = col;
		do {
			maze.setPixel(row, colIndex, 1);
			++colIndex;
		} while (colIndex < maze.getSize() && colIndex < col + lineLen);
	}
}

void SquareMazeGenerator::randomMaze(const SquareMaze_TwoBits& maze) {
	/*
		The maze generated by this function starts to look uniform and interesting for mazes with
		side length greater than 90 up to 600. I have not tested it with side length greater than 600
		so it might look good for even bigger mazes.
	*/
	
	size_t root = (size_t)sqrt(maze.getSize());
	size_t lineLen = (size_t)sqrt(root);        // Coefficient for the max line length.
	for (; lineLen > 1; --lineLen) {
		size_t lineCount = maze.getSize() / 2 * (root - lineLen);    // Coefficient for how many lines of each length.
		addVerticalLines(maze, lineCount, lineLen);
		addHorizontalLines(maze, lineCount, lineLen);
	}

	size_t dotCount = (maze.getSize() / 4) * (maze.getSize() / 4);    // Coefficient for the dot count.
	addDots(maze, dotCount);

	//std::cout << "Random maze created\n";
}

void SquareMazeGenerator::printCommands() {
	std::cout << "Available commands:\n";
	for (size_t i = 0; i < NUMBER_OF_COMMANDS; ++i) {
		std::cout << " | " << COMMANDS[i] << std::endl;
	}
}